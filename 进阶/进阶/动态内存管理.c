// 动态内存分配的函数
// 1. malloc
// 以字节为单位申请一块连续可用的内存。申请成功时返回这块内存空间的首地址；申请失败时返回空指针
// 当参数为 0 时，函数的行为未定义，取决于编译器
// 
// 2. calloc
// 以字节为单位申请一块连续可用的内存。第一个参数是要申请的空间数量；第二个参数单位是字节，是每个空间的大小
// 在申请成功时会将这块内存空间每个字节都初始化 0，返回值和 malloc 相同
// 
// 3. realloc
// 调整动态开辟内存的大小，调整后也是一块连续可用的内存
// 第一个参数是指向动态开辟内存首地址的指针；第二个参数是调整之后的大小，单位是字节
// 调整成功时将原区域数据复制到新的区域，然后释放原区域内存，并返回这块内存空间的首地址；调整失败时返回空指针，原区域不变
// 当传递空指针时会尝试分配一块新的内存
// 
// 4. free
// 用来释放动态开辟的内存，传递的指针应该是指向一块动态开辟的内存的首地址
// 如果传递的指针指向的空间不是动态开辟的，那么函数的行为未定义；如果传递空指针则函数无行为
// 
// 内存泄露
// 内存泄露就是申请的动态内存不再使用但是也不释放，甚至丢失指针。此时只有退出程序才能回收对应的内存
// 没有 free 也不代表内存空间不回收，在程序退出的时候，系统会自动回收内存空间的
// 
// 动态内存常见错误
// 1. 对 NULL 指针解引用
// 2. 对动态开辟空间越界访问
// 3. 使用 free 释放非动态开辟的内存
// 4. 使用 free 时，传递的指针没有指向动态开辟内存的首地址
// 5. 对同一块动态开辟内存多次释放
// 6. 动态开辟内存忘记释放
// 
// 注意事项
// 使用动态内存函数前后要检查指针有效性
// 如果一个指针指向动态开辟内存，不要轻易改变该指针的值
// 动态开辟的内存一定要正确释放
// 连续的内存有益于减少内存碎片，也有益于提高访问速度，因此尽量不要频繁地申请内存

#define _CRT_SECURE_NO_WARNINGS 1
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
void test_alloc()
{
	printf("\n动态内存管理\n");
	int* p = (int*)malloc(40); // 在堆区申请 40 个字节空间，申请成功时将这块空间首地址赋给 p
	if (NULL == p) // 申请失败返回 NULL
	{
		printf("%s\n", strerror(errno)); // 查看错误信息
		return;
	}

	memset(p, 0, 40);
	void* ptr = realloc(p, 80); // 将 p 指向的动态申请的空间重新分配成 80 个字节，原 40 个字节的数据也会复制过去，并将原区域释放
	if (ptr != NULL)
	{
		p = (int*)ptr;
		ptr = NULL;
	}

	printf("%s\n", strerror(errno)); // 查看错误信息
	free(p); // 释放内存
	p = NULL; // 规避野指针
}
// 每一个源文件(.c)经过编译生成一个目标文件，目标文件在 windows 环境下扩展名为 .obj，目标文件经过链接生成可执行程序
// 编译可分为 3 个阶段
// 1. 预编译/预处理
// 处理所有 # 指令，删除所有注释
// 属于文本操作，可选生成 .i 文件
// 
// 2. 编译
// 语法分析、词法分析、符号汇总、语义分析
// 生成汇编代码
// 
// 3. 汇编
// 对汇编代码二次处理，生成二进制指令，同时形成符号表
// 
// 链接包括合并段表、符号表的合并和重定位
// 
// C语言自带的预定义符号
// __FILE__		当前进行编译的源文件
// __LINE__		所在的行号
// __DATE__		编译时的日期
// __TIME__		编译时的时间
// __STDC__		当编译器遵循 ANSI C 则为 1，否则未定义
// 
// 预处理指令
// #define
// 功能是替换，如果定义的符号过长需要换行的话，需要加上续行符 \，续行符后面只能有回车
// 可以定义数字、字符串、关键字、表达式。定义的结尾最好不要加分号，因为会把分号也当作替换的一部分
// 定义的符号不会在字符串中替换
// 宏定义 #define FUNCTION(parament_list) stuff
// 宏定义要加上必要的括号，避免被操作符相互作用
// 宏调用和函数调用很像，因此将宏名全大写来方便区分
// 当实现一些小型计算时，宏的效率比函数更好，因为省去了函数调用和返回
// 宏参数是没有类型的，使得宏较为灵活，但是也不够严谨了
// 宏是不能调试的，这也是对比函数的缺点
// 
// # 和 ##
// 单个 # 可以将参数作为字符串替换
// ## 可以把两边的符号合成一个符号，但是这样的结果必须是一个合法的标识符
// 
// #undef
// 用来取消一个宏定义，如果某个已定义符号需要重新定义那么需要先取消定义
// 
// 条件编译
// #if 常量表达式
// ……
// #endif
// 当表达式为真才编译中间的内容
// 
// #if 常量表达式
// ……
// #elif 常量表达式
// ……
// #else
// ……
// #endif
// 
// 根据符号是否被定义来选择编译
// #if defined(符号)
// #ifdef 符号
// #if !defined(符号)
// #ifndef 符号
// 需要搭配 #endif
// 条件编译可以嵌套使用
// 
// #pragma once
// 防止头文件被重复包含
// 
// 包含头文件时使用尖括号会在系统标准头文件目录查找该头文件
// 使用双引号会优先在当前源文件所在目录查找，找不到才去系统标准头文件目录查找

#define F1(X) X * X // 这种写法有缺陷，当替换的参数是表达式时会出现意料之外的结果，比如 2 + 3 替换时会成为 2 + 3 * 2 + 3
#define F2(X) (X) + (X) // 这种写法也有问题，2 * F2(2 + 3) 会被替换成 2 * (2 + 3) + (2 + 3)
#define F3(X) ((X) + (X)) // 这种写法才是最准确最严谨的，但是如果这样调用 F3(n++) 就会出现问题，这个只能自己避免
#define F4(X) #X
#define F5(X, Y) X##Y
#define MALLOC(NUM, TYPE) (TYPE*)malloc((NUM) * sizeof(TYPE))

#include <stdio.h>
#include <stdlib.h>
void test_pre()
{
	printf("\n预处理\n");
	printf("filename:>\"%s\" line:>%d date:>%s time:>%s\n", __FILE__, __LINE__, __DATE__, __TIME__); // 可以用来记录日志
	printf("%d ", 10 * F3(2));
	printf("abc""def""\n"); // 相邻的字符串常量会自动合并
	printf("变量名为 "F4(a)"\n"); // printf("变量名为 ""a""\n");
	printf("表达式为 "F4(a + b)"\n");
	int ab = 12;
	printf("%d ", F5(a, b)); // printf("%d ", ab);
	int* pi = MALLOC(5, int);
	free(pi);
	pi = NULL;
}
